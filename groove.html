<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>What is Groove? ‚Äî Wet Math</title>
<style>
  :root { --bg:#09090b; --s1:#111113; --s2:#1a1a1f; --border:#2a2a30; --text:#d4d4d8; --dim:#a1a1aa; --accent:#06b6d4; --accent2:#a78bfa; --orange:#f97316; --green:#22c55e; --blue:#3b82f6; --red:#ef4444; --yellow:#eab308; }
  * { margin:0; padding:0; box-sizing:border-box; }
  body { background:var(--bg); color:var(--text); font-family:'Inter',system-ui,sans-serif; line-height:1.8; font-size:1.05rem; }
  .container { max-width:920px; margin:0 auto; padding:2rem 1.5rem; }
  h1 { font-size:2.2rem; margin-bottom:0.3rem; letter-spacing:-0.02em; }
  h2 { font-size:1.5rem; margin:3rem 0 1rem; color:var(--accent); border-bottom:1px solid var(--border); padding-bottom:0.5rem; }
  h3 { font-size:1.15rem; margin:1.5rem 0 0.5rem; color:var(--accent2); }
  p { margin-bottom:1rem; }
  a { color:var(--orange); text-decoration:none; } a:hover { text-decoration:underline; }
  .subtitle { color:var(--dim); font-size:1.05rem; margin-bottom:2.5rem; }
  .card { background:var(--s1); border:1px solid var(--border); border-radius:10px; padding:1.5rem; margin:1.2rem 0; }
  .quote { border-left:3px solid var(--accent2); padding:0.8rem 1rem; color:var(--dim); font-style:italic; margin:1.2rem 0; background:var(--s2); border-radius:0 6px 6px 0; }
  code { background:var(--s2); padding:0.15rem 0.5rem; border-radius:3px; font-size:0.9em; font-family:'Fira Code','SF Mono',monospace; }
  .connection { background:linear-gradient(135deg, var(--s1), var(--s2)); border:1px solid var(--accent); border-radius:10px; padding:1.5rem; margin:1.5rem 0; }
  .connection h3 { color:var(--orange); margin-top:0; }
  .nav { margin-bottom:2rem; }
  .nav a { background:var(--s1); border:1px solid var(--border); padding:0.4rem 0.8rem; border-radius:6px; font-size:0.85rem; transition:border-color 0.2s; }
  .nav a:hover { border-color:var(--accent); text-decoration:none; }
  button { background:var(--accent); color:white; border:none; padding:0.5rem 1.2rem; border-radius:5px; cursor:pointer; font-size:0.9rem; transition:opacity 0.2s; }
  button:hover { opacity:0.85; }
  button.secondary { background:var(--s2); color:var(--text); border:1px solid var(--border); }
  button.active { border-color:var(--accent); box-shadow:0 0 0 2px rgba(6,182,212,0.3); }
  .mode-btn { padding:0.6rem 1.2rem; border-radius:8px; font-size:0.95rem; }
  .controls { display:flex; gap:0.8rem; flex-wrap:wrap; align-items:center; margin-bottom:1rem; }
  .controls label { font-size:0.85rem; color:var(--dim); display:flex; align-items:center; gap:0.4rem; }
  input[type=range] { width:100px; accent-color:var(--accent); }
  select { background:var(--s2); color:var(--text); border:1px solid var(--border); padding:0.3rem 0.5rem; border-radius:4px; font-size:0.85rem; }
</style>
</head>
<body>
<div class="container">

<div class="nav"><a href="./">‚Üê Wet Math</a></div>

<h1>ü•Å What is Groove?</h1>
<p class="subtitle">From the grid to swing to J Dilla ‚Äî an interactive exploration of micro-timing</p>

<!-- ‚ïê‚ïê‚ïê INTRO ‚ïê‚ïê‚ïê -->
<div class="card">
<p>Every drum machine quantizes time into a grid. Hit a note, and it snaps to the nearest subdivision ‚Äî perfectly in time, perfectly dead. Real drummers don't play on the grid. The question is: <em>how</em> do they deviate, and why does it feel good?</p>
<p>Three modes of timing. Each one a different relationship with the grid.</p>
</div>

<!-- ‚ïê‚ïê‚ïê MODE SELECTOR ‚ïê‚ïê‚ïê -->
<h2>The Visualizer</h2>

<div class="card" id="viz-container">
<div class="controls">
  <button class="mode-btn active" id="btn-grid" onclick="setMode('grid')">Grid</button>
  <button class="mode-btn secondary" id="btn-swing" onclick="setMode('swing')">Swing</button>
  <button class="mode-btn secondary" id="btn-dilla" onclick="setMode('dilla')">Dilla</button>
  <span style="margin-left:1rem;"></span>
  <button id="btn-play" onclick="togglePlay()">‚ñ∂ Play</button>
  <label>BPM <input type="range" id="bpm" min="60" max="140" value="93" oninput="updateBPM()"><span id="bpm-val" style="font-family:monospace;min-width:2.5rem;">93</span></label>
</div>

<canvas id="grooveCanvas" width="900" height="340" style="width:100%; border-radius:8px;"></canvas>

<div id="mode-desc" style="margin-top:1rem; font-size:0.9rem; color:var(--dim);"></div>
</div>

<script>
(function() {
  // ‚ïê‚ïê‚ïê AUDIO ENGINE ‚ïê‚ïê‚ïê
  let audioCtx = null;
  let playing = false;
  let nextNoteTime = 0;
  let currentStep = 0;
  let timerID = null;
  let mode = 'grid';
  let bpm = 93;
  const STEPS = 16;
  const LOOKAHEAD = 25.0; // ms
  const SCHEDULEAHEAD = 0.1; // s

  // Instruments: kick, snare, hihat, rim
  const tracks = [
    { name: 'Kick',  color: '#f97316', pattern: [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0] },
    { name: 'Snare', color: '#a78bfa', pattern: [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0] },
    { name: 'HiHat', color: '#06b6d4', pattern: [1,0,1,0, 1,0,1,0, 1,0,1,0, 1,0,1,0] },
    { name: 'Rim',   color: '#22c55e', pattern: [0,0,0,0, 0,0,1,0, 0,0,0,0, 0,1,0,0] },
  ];

  // Per-step timing offsets (in fractions of a step duration)
  // These define the "feel" for each mode
  function getOffsets(m) {
    const zero = Array.from({length: STEPS}, () => Array(tracks.length).fill(0));
    if (m === 'grid') return zero;
    if (m === 'swing') {
      // Classic MPC swing: push every even 16th note late
      // Same offset for all instruments ‚Äî unified feel
      const swingAmt = 0.33; // 33% of a step
      return Array.from({length: STEPS}, (_, i) =>
        tracks.map(() => i % 2 === 1 ? swingAmt : 0)
      );
    }
    if (m === 'dilla') {
      // J Dilla: each instrument has its OWN timing relationship
      // Kick slightly ahead, snare slightly behind, hihat swings,
      // rim has its own pocket ‚Äî nothing lines up, everything grooves
      const offsets = Array.from({length: STEPS}, () => Array(tracks.length).fill(0));
      for (let i = 0; i < STEPS; i++) {
        // Kick: slightly ahead of the beat (pushing)
        offsets[i][0] = (i % 4 === 0) ? -0.08 : (i % 2 === 0) ? -0.05 : 0;
        // Snare: laid back, behind the beat
        offsets[i][1] = (i % 4 === 0) ? 0.15 : 0.12;
        // HiHat: uneven swing, different per beat ‚Äî the Dilla shuffle
        offsets[i][2] = (i % 4 === 1) ? 0.28 : (i % 4 === 3) ? 0.38 : (i % 2 === 1) ? 0.22 : 0.03;
        // Rim: its own world ‚Äî slightly different from everything
        offsets[i][3] = (i % 3 === 0) ? 0.1 : (i % 3 === 1) ? -0.06 : 0.2;
      }
      return offsets;
    }
    return zero;
  }

  let offsets = getOffsets(mode);

  // Synthesize percussion sounds
  function playSound(trackIdx, time) {
    if (!audioCtx) return;
    const t = trackIdx;
    if (t === 0) { // Kick
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.frequency.setValueAtTime(160, time);
      osc.frequency.exponentialRampToValueAtTime(40, time + 0.12);
      gain.gain.setValueAtTime(0.8, time);
      gain.gain.exponentialRampToValueAtTime(0.001, time + 0.3);
      osc.connect(gain); gain.connect(audioCtx.destination);
      osc.start(time); osc.stop(time + 0.3);
    } else if (t === 1) { // Snare
      const noise = audioCtx.createBufferSource();
      const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.15, audioCtx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
      noise.buffer = buf;
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'highpass'; filter.frequency.value = 1000;
      gain.gain.setValueAtTime(0.5, time);
      gain.gain.exponentialRampToValueAtTime(0.001, time + 0.15);
      noise.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination);
      noise.start(time); noise.stop(time + 0.15);
      // Tonal body
      const osc = audioCtx.createOscillator();
      const g2 = audioCtx.createGain();
      osc.frequency.setValueAtTime(200, time);
      osc.frequency.exponentialRampToValueAtTime(100, time + 0.05);
      g2.gain.setValueAtTime(0.4, time);
      g2.gain.exponentialRampToValueAtTime(0.001, time + 0.08);
      osc.connect(g2); g2.connect(audioCtx.destination);
      osc.start(time); osc.stop(time + 0.08);
    } else if (t === 2) { // HiHat
      const noise = audioCtx.createBufferSource();
      const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.05, audioCtx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
      noise.buffer = buf;
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'highpass'; filter.frequency.value = 7000;
      gain.gain.setValueAtTime(0.25, time);
      gain.gain.exponentialRampToValueAtTime(0.001, time + 0.05);
      noise.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination);
      noise.start(time); noise.stop(time + 0.05);
    } else if (t === 3) { // Rim
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(800, time);
      gain.gain.setValueAtTime(0.2, time);
      gain.gain.exponentialRampToValueAtTime(0.001, time + 0.03);
      osc.connect(gain); gain.connect(audioCtx.destination);
      osc.start(time); osc.stop(time + 0.03);
    }
  }

  function scheduleNote(step, time) {
    const stepDur = (60.0 / bpm) / 4; // 16th note duration
    for (let t = 0; t < tracks.length; t++) {
      if (tracks[t].pattern[step]) {
        const offset = offsets[step][t] * stepDur;
        playSound(t, time + offset);
      }
    }
  }

  function scheduler() {
    while (nextNoteTime < audioCtx.currentTime + SCHEDULEAHEAD) {
      scheduleNote(currentStep, nextNoteTime);
      const stepDur = (60.0 / bpm) / 4;
      nextNoteTime += stepDur;
      currentStep = (currentStep + 1) % STEPS;
    }
    timerID = setTimeout(scheduler, LOOKAHEAD);
  }

  window.togglePlay = function() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (playing) {
      clearTimeout(timerID);
      playing = false;
      document.getElementById('btn-play').textContent = '‚ñ∂ Play';
    } else {
      currentStep = 0;
      nextNoteTime = audioCtx.currentTime;
      playing = true;
      document.getElementById('btn-play').textContent = '‚è∏ Pause';
      scheduler();
    }
  };

  window.setMode = function(m) {
    mode = m;
    offsets = getOffsets(m);
    document.querySelectorAll('.mode-btn').forEach(b => { b.classList.remove('active'); b.classList.add('secondary'); });
    document.getElementById('btn-' + m).classList.remove('secondary');
    document.getElementById('btn-' + m).classList.add('active');
    const descs = {
      grid: '<strong>Grid:</strong> Every note snaps to exact 16th-note subdivisions. Perfectly quantized. Metronomically correct. Completely lifeless. This is what a drum machine sounds like with no feel applied ‚Äî every instrument locked to the same rigid grid.',
      swing: '<strong>Swing:</strong> Every other 16th note is pushed late by the same amount, across all instruments. This is the classic MPC/drum machine swing ‚Äî syncopated, bouncy, but <em>uniform</em>. All parts share one deformed grid. Feels good, but predictable.',
      dilla: '<strong>Dilla:</strong> Each instrument has its <em>own</em> timing relationship with the beat. The kick pushes slightly ahead. The snare lays back behind. The hi-hat swings unevenly ‚Äî different amounts on different beats. The rim lives in its own pocket. Nothing lines up with anything else, but nothing is random either. Every deviation has structure. This is the liquid state of rhythm ‚Äî the commutator is non-zero and patterned.'
    };
    document.getElementById('mode-desc').innerHTML = descs[m];
    draw();
  };

  window.updateBPM = function() {
    bpm = parseInt(document.getElementById('bpm').value);
    document.getElementById('bpm-val').textContent = bpm;
  };

  // ‚ïê‚ïê‚ïê VISUALIZATION ‚ïê‚ïê‚ïê
  function draw() {
    const canvas = document.getElementById('grooveCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    ctx.fillStyle = '#09090b';
    ctx.fillRect(0, 0, W, H);

    const marginL = 60, marginR = 20, marginT = 30, marginB = 20;
    const plotW = W - marginL - marginR;
    const plotH = H - marginT - marginB;
    const trackH = plotH / tracks.length;
    const stepW = plotW / STEPS;

    // Grid lines (the reference grid ‚Äî always shown)
    ctx.strokeStyle = '#1a1a1f';
    ctx.lineWidth = 1;
    for (let i = 0; i <= STEPS; i++) {
      const x = marginL + i * stepW;
      ctx.beginPath(); ctx.moveTo(x, marginT); ctx.lineTo(x, marginT + plotH); ctx.stroke();
      // Beat numbers
      if (i % 4 === 0 && i < STEPS) {
        ctx.fillStyle = '#555';
        ctx.font = '11px Inter, system-ui, sans-serif';
        ctx.fillText((i/4 + 1).toString(), x + stepW * 1.5, marginT - 8);
      }
    }
    // Stronger lines on quarter notes
    ctx.strokeStyle = '#2a2a30';
    ctx.lineWidth = 1.5;
    for (let i = 0; i <= 4; i++) {
      const x = marginL + i * 4 * stepW;
      ctx.beginPath(); ctx.moveTo(x, marginT); ctx.lineTo(x, marginT + plotH); ctx.stroke();
    }

    // Track labels
    ctx.font = '12px Inter, system-ui, sans-serif';
    for (let t = 0; t < tracks.length; t++) {
      ctx.fillStyle = tracks[t].color;
      const y = marginT + t * trackH + trackH / 2 + 4;
      ctx.fillText(tracks[t].name, 8, y);
    }

    // Draw notes ‚Äî circles positioned at their actual timing
    for (let t = 0; t < tracks.length; t++) {
      for (let s = 0; s < STEPS; s++) {
        if (!tracks[t].pattern[s]) continue;
        const offset = offsets[s][t];
        const x = marginL + (s + 0.5 + offset) * stepW;
        const y = marginT + t * trackH + trackH / 2;
        const r = 7;

        // Draw a ghost circle on the grid position if offset
        if (Math.abs(offset) > 0.01) {
          const gx = marginL + (s + 0.5) * stepW;
          ctx.beginPath(); ctx.arc(gx, y, r, 0, Math.PI * 2);
          ctx.strokeStyle = tracks[t].color + '30';
          ctx.lineWidth = 1;
          ctx.stroke();
          // Connecting line
          ctx.beginPath(); ctx.moveTo(gx, y); ctx.lineTo(x, y);
          ctx.strokeStyle = tracks[t].color + '40';
          ctx.lineWidth = 1;
          ctx.stroke();
        }

        // Actual note
        ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fillStyle = tracks[t].color;
        ctx.fill();
      }
    }

    // Playhead
    if (playing && audioCtx) {
      const stepDur = (60.0 / bpm) / 4;
      const totalDur = stepDur * STEPS;
      const elapsed = (audioCtx.currentTime - (nextNoteTime - stepDur * ((currentStep === 0 ? STEPS : currentStep)))) % totalDur;
      const progress = elapsed / totalDur;
      const px = marginL + progress * plotW;

      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(px, marginT); ctx.lineTo(px, marginT + plotH); ctx.stroke();

      // Glow
      ctx.strokeStyle = 'rgba(255,255,255,0.15)';
      ctx.lineWidth = 8;
      ctx.beginPath(); ctx.moveTo(px, marginT); ctx.lineTo(px, marginT + plotH); ctx.stroke();
    }

    requestAnimationFrame(draw);
  }

  // Initialize
  setMode('grid');
  draw();
})();
</script>

<!-- ‚ïê‚ïê‚ïê THE THREE MODES ‚ïê‚ïê‚ïê -->
<h2>The Three Modes</h2>

<div class="card">
<h3 style="color:var(--dim);">1. Grid ‚Äî The Solid State</h3>
<p>Every note snaps to the nearest 16th-note subdivision. All instruments share the same rigid grid. This is G = 0 ‚Äî operations commute, nothing depends on order, the system is frozen. It's technically "correct" and completely dead.</p>
<p>Most electronic music starts here and adds complexity on top. But the grid itself has no groove. It's Class I ‚Äî a fixed point.</p>
</div>

<div class="card">
<h3 style="color:var(--yellow);">2. Swing ‚Äî The Warm Lattice</h3>
<p>Push every other 16th note late by a fixed percentage. All instruments share this deformed grid ‚Äî they all swing together, by the same amount. This is your classic MPC swing, your jazz shuffle, your boom-bap bounce.</p>
<p>Swing introduces non-commutativity at the note level (early and late positions aren't interchangeable), but it's <em>uniform</em> ‚Äî every instrument responds the same way. It's more alive than the grid, but still predictable. Class II: periodic, structured, but not computing.</p>
</div>

<div class="card">
<h3 style="color:var(--orange);">3. Dilla ‚Äî The Liquid State</h3>
<p>James Dewitt Yancey (J Dilla, 1974‚Äì2006) did something nobody had done before: he gave each instrument its <em>own</em> timing relationship with the beat. The kick pushes ahead. The snare lays back. The hi-hat swings unevenly ‚Äî different amounts on different beats. The rim sits in its own pocket entirely.</p>
<p>Nothing lines up with anything else. But nothing is random. Every deviation has structure. If you tried to quantize it, it would die. If you randomized the offsets, it would be noise. The deviations are <em>patterned non-commutations</em> ‚Äî the instruments don't agree on where the beat is, and the structure of that disagreement is the groove.</p>
<p>This is Class IV. This is the liquid state. This is <strong>G ‚â† 0 with structure</strong>.</p>
</div>

<!-- ‚ïê‚ïê‚ïê CONNECTION ‚ïê‚ïê‚ïê -->
<div class="connection">
<h3>üîó The Commutator in Rhythm</h3>
<p>The Groovy Commutator was literally named for this. Take "evolve" (advance to the next beat) and "differentiate" (measure the deviation from the grid). Swap the order. In grid mode, the result is always zero ‚Äî the grid commutes. In swing mode, it's non-zero but uniform. In Dilla mode, it's non-zero and <em>structured differently for each instrument</em>.</p>
<p>The commutator doesn't just detect groove ‚Äî it measures the <em>kind</em> of groove. The pattern of non-commutation IS the feel. <a href="./commutator.html">Read more ‚Üí</a></p>
</div>

<!-- ‚ïê‚ïê‚ïê FOOTER ‚ïê‚ïê‚ïê -->
<div style="margin-top:3rem; padding-top:1.5rem; border-top:1px solid var(--border); text-align:center; color:var(--dim); font-size:0.9rem;">
  <p><a href="./">‚Üê Back to Wet Math</a></p>
  <p style="margin-top:0.5rem; font-size:0.8rem;">Inspired by Dan Charnas's <em>Dilla Time</em> and <a href="https://d-buckner.github.io/dilla-time/">d-buckner's visualization</a>.</p>
</div>

</div>
</body>
</html>
