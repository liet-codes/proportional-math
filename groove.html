<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>What is Groove? ‚Äî Wet Math</title>
<style>
  :root { --bg:#09090b; --s1:#111113; --s2:#1a1a1f; --border:#2a2a30; --text:#d4d4d8; --dim:#a1a1aa; --accent:#06b6d4; --accent2:#a78bfa; --orange:#f97316; --green:#22c55e; --blue:#3b82f6; --red:#ef4444; --yellow:#eab308; }
  * { margin:0; padding:0; box-sizing:border-box; }
  body { background:var(--bg); color:var(--text); font-family:'Inter',system-ui,sans-serif; line-height:1.8; font-size:1.05rem; }
  .container { max-width:860px; margin:0 auto; padding:2rem 1.5rem; }
  h1 { font-size:2.5rem; margin-bottom:0.3rem; letter-spacing:-0.02em; }
  h2 { font-size:1.8rem; margin:4rem 0 1rem; color:var(--accent); border-bottom:1px solid var(--border); padding-bottom:0.5rem; }
  h3 { font-size:1.15rem; margin:1.5rem 0 0.5rem; color:var(--accent2); }
  p { margin-bottom:1rem; }
  a { color:var(--orange); text-decoration:none; } a:hover { text-decoration:underline; }
  .subtitle { color:var(--dim); font-size:1.1rem; margin-bottom:2.5rem; }
  .card { background:var(--s1); border:1px solid var(--border); border-radius:10px; padding:1.5rem; margin:1.2rem 0; }
  .quote { border-left:3px solid var(--accent2); padding:0.8rem 1rem; color:var(--dim); font-style:italic; margin:1.2rem 0; background:var(--s2); border-radius:0 6px 6px 0; }
  .quote cite { display:block; margin-top:0.5rem; font-style:normal; font-size:0.85rem; color:var(--accent2); }
  code { background:var(--s2); padding:0.15rem 0.5rem; border-radius:3px; font-size:0.9em; font-family:'Fira Code','SF Mono',monospace; }
  .connection { background:linear-gradient(135deg, var(--s1), var(--s2)); border:1px solid var(--accent); border-radius:10px; padding:1.5rem; margin:1.5rem 0; }
  .connection h3 { color:var(--orange); margin-top:0; }
  .nav { margin-bottom:2rem; }
  .nav a { background:var(--s1); border:1px solid var(--border); padding:0.4rem 0.8rem; border-radius:6px; font-size:0.85rem; }
  .nav a:hover { border-color:var(--accent); text-decoration:none; }
  .viz-wrap { background:#0d0d0f; border:1px solid var(--border); border-radius:12px; overflow:hidden; margin:1.5rem 0; }
  .viz-wrap canvas { width:100%; display:block; }
  .viz-controls { background:#111114; padding:0.8rem 1rem; display:flex; align-items:center; gap:0.6rem; border-top:1px solid var(--border); }
  .viz-controls button { background:#1e1e22; color:var(--text); border:1px solid #333; padding:0.4rem 1rem; border-radius:5px; cursor:pointer; font-size:0.85rem; font-family:inherit; transition:all 0.15s; }
  .viz-controls button:hover { border-color:#555; }
  .viz-controls button.on { background:var(--orange); color:white; border-color:var(--orange); }
  .viz-controls .play-btn { background:var(--s2); width:36px; height:36px; border-radius:50%; display:flex; align-items:center; justify-content:center; padding:0; font-size:1rem; }
  .era { font-size:0.85rem; display:inline-block; padding:0.2rem 0.6rem; border-radius:4px; margin-bottom:0.5rem; }
</style>
</head>
<body>
<div class="container">

<div class="nav"><a href="./">‚Üê Wet Math</a></div>

<h1>ü•Å What is Groove?</h1>
<p class="subtitle">From the grid to swing to J Dilla ‚Äî an interactive exploration of micro-timing</p>

<div class="card">
<p>This started when Brooklyn ‚Äî jazz drummer, musical polymath ‚Äî told Myk she thought groove might have something to do with Class IV cellular automata. The intuition: groove isn't randomness and it isn't precision. It's the zone between.</p>
<p>Your body already knows this. When a beat grooves, you don't analyze it ‚Äî you <em>feel</em> it. That felt sense is your somatic resonance sensorium detecting structured non-commutativity. The commutator is non-zero, and it has pattern, and your body says <em>yes</em>.</p>
<p>Groove is one element of music among many ‚Äî grid-based music isn't lesser, it simply puts its energy elsewhere (arrangement, timbre, dynamics). But groove specifically lives in <em>timing</em>, in the micro-relationships between when things happen. Here's a history of how rhythm found the liquid state.</p>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<!-- SECTION 1: THE GRID                         -->
<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<h2>1. The Grid</h2>

<div class="card">
<p>Before drum machines, rhythm was always human ‚Äî imprecise by nature. Then in 1980, the Linn LM-1 arrived, and for the first time, you could program beats on an exact grid. Every hit snaps to the nearest subdivision. Perfectly in time.</p>
<p>The grid is enormously powerful. It democratized rhythm ‚Äî suddenly anyone could make beats without being a drummer. Kraftwerk, early hip-hop, house, techno, and most electronic music are built on the grid. There's a precision and clarity to it that enables forms of complexity that would be impossible with loose timing.</p>
<p>But from a groove perspective, the grid <em>commutes</em>: every instrument shares the same time reference, every beat is equidistant from its neighbors. There's no tension between parts, no push-and-pull. The timing dimension carries no information beyond "on" or "off."</p>
</div>

<div id="viz-grid"></div>

<div class="card">
<h3>The Somatics</h3>
<p>You can nod to a grid beat ‚Äî you might even bang your head to it. But the timing itself doesn't pull your body in different directions. The signal is fully predictable in the time domain, so your body engages with <em>other</em> aspects ‚Äî the timbre, the dynamics, the arrangement ‚Äî while the timing fades into background.</p>

<h3>Who Does This</h3>
<p>Kraftwerk, 808 State, early Detroit techno, most EDM. Also: any MIDI sequence with quantize on. The grid is the default.</p>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<!-- SECTION 2: SWING                             -->
<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<h2>2. Swing</h2>

<div class="card">
<p>Roger Linn knew the grid needed something. So the MPC60 (1988) shipped with a swing knob: push every other 16th note late by a percentage. 50% = straight. 66% = triplet feel. Anywhere in between = bounce.</p>
<p>Swing is a <em>uniform deformation</em> of the grid. Every instrument swings together, by the same amount. It's a single parameter applied globally ‚Äî one shared, warped grid. The non-commutativity is real (early and late positions aren't interchangeable), and it grooves. Your body responds to the push-pull of the deformed grid.</p>
<p>But it's the same deformation for everyone. One number. One feel. Predictable once you're locked in.</p>
</div>

<div id="viz-swing"></div>

<div class="card">
<h3>The Somatics</h3>
<p>Swing makes you bounce. The anticipation of the late note, the slight tension before it lands ‚Äî your body detects the non-zero commutator and responds. You settle into the pocket. It's comfortable, warm, infectious. Jazz has been doing this with human hands for a century; the MPC compressed it into a knob.</p>

<h3>Who Does This</h3>
<p>Pete Rock, DJ Premier, the Bomb Squad, golden-age hip-hop. Also: every jazz drummer since the 1920s, doing it naturally with their bodies. The specific swing percentage became a producer signature ‚Äî Premier's beats swing differently from Pete Rock's.</p>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<!-- SECTION 3: DILLA                             -->
<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<h2>3. Dilla Time</h2>

<div class="card">
<p>James Dewitt Yancey ‚Äî J Dilla (1974‚Äì2006) ‚Äî broke the grid in a way nobody had before and nobody has fully replicated since.</p>
<p>He turned off the quantize. He played each part by hand on the MPC pads, and he <em>didn't correct it</em>. But here's what makes it Dilla and not just sloppy: each instrument has its <strong>own timing relationship</strong> with the beat. The kick pushes slightly ahead ‚Äî anxious, leaning in. The snare lays back ‚Äî lazy, behind. The hi-hat swings unevenly ‚Äî different amounts on different beats. Nothing lines up with anything else.</p>
<p>And it grooves harder than anything on the grid.</p>
</div>

<div id="viz-dilla"></div>

<div class="card">
<p>The deviations aren't random. If you randomized the timing, it would sound drunk (we'll hear that next). If you quantized it, it would lose the feel. The deviations have <em>pattern</em> ‚Äî each instrument's relationship to the beat is consistent within itself but different from every other instrument. It's polyphonic non-commutativity: multiple structured deviations interfering with each other.</p>

<h3>The Somatics</h3>
<p>Dilla Time does something to your body that no other feel does. Different parts of you respond to different instruments. Your head follows the hi-hat. Your chest follows the kick. Your shoulders follow the snare. You become a distributed system, each part coupled to its own timing stream, coherent without centralization. This is the somatic resonance sensorium at full activation.</p>

<h3>Who Does This</h3>
<p><em>Donuts</em> (2006), released three days before his death, is the masterpiece. Madlib, Knxwledge, Kaytranada, Flying Lotus ‚Äî all descendants. But nobody sounds exactly like Dilla, because the feel isn't a technique. It's a relationship with time.</p>
</div>

<div class="quote">
"He had his own time signature. It wasn't behind the beat, it wasn't ahead of the beat. It was in its own time zone."
<cite>‚Äî Questlove on J Dilla</cite>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<!-- SECTION 4: NOISE                             -->
<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<h2>4. Noise</h2>

<div class="card">
<p>To hear why Dilla's deviations aren't random, listen to what random actually sounds like. Same pattern, same instruments ‚Äî but every loop, each hit gets a random timing offset. No structure. No pattern. Just chaos.</p>
<p>Your body knows the difference immediately. Dilla feels alive; this feels broken. That distinction ‚Äî between structured and random non-commutativity ‚Äî is exactly what the groovy commutator measures.</p>
</div>

<div id="viz-noise"></div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<!-- SECTION 5: THE GRID AS FOIL                  -->
<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<h2>5. The Grid as Foil</h2>

<div class="card">
<p>There's another way to groove that doesn't fit neatly into the taxonomy above: using the grid <em>as a foil</em>. Prince is the master of this. He programs tight, mechanical drum machine patterns ‚Äî and then plays guitar, bass, and vocals <em>against</em> them, with deeply human timing. The grid becomes a rigid reference that makes the human deviations <em>more</em> perceptible, not less.</p>
<p>The commutator here is between the mechanized rhythm section and the human performance on top. The grid doesn't groove; it <em>enables</em> groove by providing a crystalline lattice for the human parts to push and pull against. It's a different architecture ‚Äî the non-commutativity lives between layers rather than within the rhythm section itself.</p>
<p>James Brown did something similar ‚Äî the band locks into a groove so tight it's almost mechanical, and the vocals float on top. The tighter the pocket, the more the deviations shine.</p>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<!-- CONNECTION TO WET MATH                       -->
<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="connection" style="margin-top:3rem;">
<h3>üîó The Commutator in Rhythm</h3>
<p>The Groovy Commutator was literally named for this. These modes of timing trace a path from fully commutative (grid ‚Äî every part interchangeable) through uniformly non-commutative (swing ‚Äî structured but one-dimensional) to polyphonically non-commutative (Dilla ‚Äî each voice structured in its own way). Noise is the control: non-commutative but structureless.</p>
<p>The mapping to Wolfram classes and phases of matter is suggestive but loose ‚Äî rhythm is one domain, CAs are another, and the operators are different. What's preserved across domains is the <em>architecture</em>: measure where order matters, and ask whether the result has pattern. <a href="./commutator.html">Read the full math ‚Üí</a></p>
</div>

<!-- ‚ïê‚ïê‚ïê FOOTER ‚ïê‚ïê‚ïê -->
<div style="margin-top:3rem; padding-top:1.5rem; border-top:1px solid var(--border); text-align:center; color:var(--dim); font-size:0.9rem;">
  <p><a href="./">‚Üê Back to Wet Math</a></p>
  <p style="margin-top:0.5rem; font-size:0.8rem;">Inspired by Dan Charnas's <em>Dilla Time</em> (2022) and <a href="https://d-buckner.github.io/dilla-time/">d-buckner's visualization</a>. BPM 93 ‚Äî Dilla's tempo.</p>
</div>

</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<!-- ENGINE: AUDIO + DEFORMING GRID VIZ           -->
<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<script>
(function() {
  const BPM = 93;
  const STEPS = 16;
  const STEP_DUR = (60 / BPM) / 4;
  const LOOP_DUR = STEP_DUR * STEPS;

  const TRACKS = [
    { name: 'HiHat', color: '#f97316', pattern: [1,0,1,0, 1,0,1,0, 1,0,1,0, 1,0,1,0] },
    { name: 'Kick',  color: '#f97316', pattern: [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0] },
    { name: 'Snare', color: '#f97316', pattern: [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0] },
    { name: 'Rim',   color: '#f97316', pattern: [0,0,0,0, 0,0,1,0, 0,0,0,0, 0,1,0,0] },
  ];

  // Returns per-step widths (as fractions of total, summing to 1) for each track
  function getWidths(mode) {
    const equal = 1 / STEPS;
    if (mode === 'grid') {
      return TRACKS.map(() => new Array(STEPS).fill(equal));
    }
    if (mode === 'swing') {
      // Alternating long-short, same for all tracks
      const long = equal * 1.33;
      const short = equal * 0.67;
      return TRACKS.map(() => {
        const w = [];
        for (let i = 0; i < STEPS; i++) w.push(i % 2 === 0 ? long : short);
        return w;
      });
    }
    if (mode === 'dilla') {
      // Each track has its own deformation
      return TRACKS.map((_, t) => {
        const w = [];
        for (let i = 0; i < STEPS; i++) {
          // Base width with per-track, per-step variation
          const seed = Math.sin((t + 1) * 7.3 + i * 3.7) * 0.4 + 1;
          w.push(equal * seed);
        }
        // Normalize to sum to 1
        const sum = w.reduce((a, b) => a + b, 0);
        return w.map(v => v / sum);
      });
    }
    if (mode === 'noise') {
      // Random each time (re-randomized per loop in audio scheduler)
      return TRACKS.map(() => {
        const w = [];
        for (let i = 0; i < STEPS; i++) w.push(equal * (0.5 + Math.random()));
        const sum = w.reduce((a, b) => a + b, 0);
        return w.map(v => v / sum);
      });
    }
    return TRACKS.map(() => new Array(STEPS).fill(equal));
  }

  // Convert widths to cumulative timing offsets (0-1 range)
  function widthsToTiming(widths) {
    return widths.map(row => {
      const t = [0];
      let cum = 0;
      for (let i = 0; i < row.length; i++) { cum += row[i]; t.push(cum); }
      return t; // length = STEPS+1
    });
  }

  // ‚ïê‚ïê‚ïê AUDIO ‚ïê‚ïê‚ïê
  let actx = null;
  function getCtx() {
    if (!actx) actx = new (window.AudioContext || window.webkitAudioContext)();
    return actx;
  }

  function playSound(ctx, trackIdx, time) {
    const t = TRACKS[trackIdx].name;
    if (t === 'Kick') {
      const osc = ctx.createOscillator();
      const g = ctx.createGain();
      osc.frequency.setValueAtTime(160, time);
      osc.frequency.exponentialRampToValueAtTime(40, time + 0.12);
      g.gain.setValueAtTime(0.7, time);
      g.gain.exponentialRampToValueAtTime(0.001, time + 0.3);
      osc.connect(g); g.connect(ctx.destination);
      osc.start(time); osc.stop(time + 0.3);
    } else if (t === 'Snare') {
      const noise = ctx.createBufferSource();
      const buf = ctx.createBuffer(1, ctx.sampleRate * 0.12, ctx.sampleRate);
      const d = buf.getChannelData(0);
      for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
      noise.buffer = buf;
      const g = ctx.createGain();
      const f = ctx.createBiquadFilter();
      f.type = 'highpass'; f.frequency.value = 1200;
      g.gain.setValueAtTime(0.45, time);
      g.gain.exponentialRampToValueAtTime(0.001, time + 0.12);
      noise.connect(f); f.connect(g); g.connect(ctx.destination);
      noise.start(time); noise.stop(time + 0.12);
      const osc = ctx.createOscillator();
      const g2 = ctx.createGain();
      osc.frequency.setValueAtTime(180, time);
      osc.frequency.exponentialRampToValueAtTime(80, time + 0.04);
      g2.gain.setValueAtTime(0.35, time);
      g2.gain.exponentialRampToValueAtTime(0.001, time + 0.06);
      osc.connect(g2); g2.connect(ctx.destination);
      osc.start(time); osc.stop(time + 0.06);
    } else if (t === 'HiHat') {
      const noise = ctx.createBufferSource();
      const buf = ctx.createBuffer(1, ctx.sampleRate * 0.04, ctx.sampleRate);
      const d = buf.getChannelData(0);
      for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
      noise.buffer = buf;
      const g = ctx.createGain();
      const f = ctx.createBiquadFilter();
      f.type = 'highpass'; f.frequency.value = 8000;
      g.gain.setValueAtTime(0.2, time);
      g.gain.exponentialRampToValueAtTime(0.001, time + 0.04);
      noise.connect(f); f.connect(g); g.connect(ctx.destination);
      noise.start(time); noise.stop(time + 0.04);
    } else if (t === 'Rim') {
      const osc = ctx.createOscillator();
      const g = ctx.createGain();
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(850, time);
      g.gain.setValueAtTime(0.18, time);
      g.gain.exponentialRampToValueAtTime(0.001, time + 0.025);
      osc.connect(g); g.connect(ctx.destination);
      osc.start(time); osc.stop(time + 0.025);
    }
  }

  // ‚ïê‚ïê‚ïê PLAYER ‚ïê‚ïê‚ïê
  const instances = {};

  function createInstance(mode, containerId) {
    const container = document.getElementById(containerId);
    if (!container) return null;

    // Build DOM
    const wrap = document.createElement('div');
    wrap.className = 'viz-wrap';
    const canvas = document.createElement('canvas');
    canvas.width = 900; canvas.height = 220;
    wrap.appendChild(canvas);
    const controls = document.createElement('div');
    controls.className = 'viz-controls';
    const playBtn = document.createElement('button');
    playBtn.className = 'play-btn';
    playBtn.textContent = '‚ñ∂';
    controls.appendChild(playBtn);
    wrap.appendChild(controls);
    container.appendChild(wrap);

    let widths = getWidths(mode);
    let timing = widthsToTiming(widths);
    let playing = false;
    let loopStart = 0;
    let scheduledUpTo = 0;
    let loopCount = 0;

    function scheduleLoop(from) {
      // For noise mode, re-randomize widths each loop
      if (mode === 'noise') {
        widths = getWidths('noise');
        timing = widthsToTiming(widths);
      }
      const ctx = getCtx();
      for (let t = 0; t < TRACKS.length; t++) {
        for (let s = 0; s < STEPS; s++) {
          if (!TRACKS[t].pattern[s]) continue;
          const noteTime = from + timing[t][s] * LOOP_DUR;
          if (noteTime >= scheduledUpTo) {
            playSound(ctx, t, noteTime);
          }
        }
      }
      scheduledUpTo = from + LOOP_DUR;
    }

    function tick() {
      if (!playing) return;
      const ctx = getCtx();
      while (scheduledUpTo < ctx.currentTime + 0.2) {
        const nextLoopStart = loopStart + Math.ceil((scheduledUpTo - loopStart) / LOOP_DUR) * LOOP_DUR;
        scheduleLoop(nextLoopStart);
      }
      requestAnimationFrame(tick);
    }

    function draw() {
      const ctx2d = canvas.getContext('2d');
      const W = canvas.width, H = canvas.height;
      ctx2d.fillStyle = '#0d0d0f';
      ctx2d.fillRect(0, 0, W, H);

      const pad = 8;
      const trackH = (H - pad * 2) / TRACKS.length;
      const cellPad = 3;

      // Compute playhead position
      let progress = -1;
      if (playing && actx) {
        progress = ((actx.currentTime - loopStart) % LOOP_DUR) / LOOP_DUR;
        if (progress < 0) progress += 1;
      }

      for (let t = 0; t < TRACKS.length; t++) {
        const y = pad + t * trackH;
        const tw = timing[t]; // cumulative positions

        for (let s = 0; s < STEPS; s++) {
          const x0 = pad + tw[s] * (W - pad * 2);
          const x1 = pad + tw[s + 1] * (W - pad * 2);
          const cw = x1 - x0;

          const isActive = TRACKS[t].pattern[s];

          // Is playhead in this cell?
          const cellStart = tw[s];
          const cellEnd = tw[s + 1];
          const isPlaying = playing && progress >= cellStart && progress < cellEnd;

          if (isActive) {
            // Glow underneath
            if (isPlaying) {
              ctx2d.shadowColor = '#f97316';
              ctx2d.shadowBlur = 15;
            }

            // Gradient pad
            const grad = ctx2d.createLinearGradient(x0, y + cellPad, x0, y + trackH - cellPad);
            grad.addColorStop(0, isPlaying ? '#ff8c3a' : '#e8651a');
            grad.addColorStop(0.3, isPlaying ? '#f97316' : '#d4580f');
            grad.addColorStop(1, isPlaying ? '#c45a10' : '#8b3d08');
            ctx2d.fillStyle = grad;
            ctx2d.beginPath();
            ctx2d.roundRect(x0 + cellPad, y + cellPad, cw - cellPad * 2, trackH - cellPad * 2, 4);
            ctx2d.fill();

            // Highlight edge
            ctx2d.strokeStyle = isPlaying ? '#ffaa55' : '#f9731640';
            ctx2d.lineWidth = 1;
            ctx2d.stroke();

            ctx2d.shadowColor = 'transparent';
            ctx2d.shadowBlur = 0;
          } else {
            // Inactive cell
            ctx2d.fillStyle = '#161619';
            ctx2d.beginPath();
            ctx2d.roundRect(x0 + cellPad, y + cellPad, cw - cellPad * 2, trackH - cellPad * 2, 4);
            ctx2d.fill();
            ctx2d.strokeStyle = '#222225';
            ctx2d.lineWidth = 0.5;
            ctx2d.stroke();
          }
        }
      }

      // Playhead line
      if (playing && progress >= 0) {
        const px = pad + progress * (W - pad * 2);
        ctx2d.strokeStyle = 'rgba(255,255,255,0.6)';
        ctx2d.lineWidth = 2;
        ctx2d.beginPath(); ctx2d.moveTo(px, 0); ctx2d.lineTo(px, H); ctx2d.stroke();
      }

      requestAnimationFrame(draw);
    }

    playBtn.addEventListener('click', () => {
      // Stop all others first
      Object.values(instances).forEach(inst => {
        if (inst && inst !== self && inst.playing) inst.stop();
      });

      if (!playing) {
        const ctx = getCtx();
        if (ctx.state === 'suspended') ctx.resume();
        playing = true;
        loopStart = ctx.currentTime;
        scheduledUpTo = loopStart;
        scheduleLoop(loopStart);
        tick();
        playBtn.textContent = '‚è∏';
      } else {
        playing = false;
        playBtn.textContent = '‚ñ∂';
      }
    });

    const self = {
      get playing() { return playing; },
      stop() { playing = false; playBtn.textContent = '‚ñ∂'; }
    };

    draw();
    instances[mode] = self;
    return self;
  }

  // Create all instances
  createInstance('grid', 'viz-grid');
  createInstance('swing', 'viz-swing');
  createInstance('dilla', 'viz-dilla');
  createInstance('noise', 'viz-noise');
})();
</script>

</body>
</html>
